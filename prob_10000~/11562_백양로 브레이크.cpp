/*
문제
남규의 프로그램은 간단하다.
출발지와 도착지를 입력하면 도착지까지 가기 위해 최소 몇 개의 길을 양방향으로 바꿔야만 하는지를 출력해준다.
프로그램이 완성되었다는 소문이 퍼지자, 남규처럼 길을 잃고 헤맨 경험이 있는 학생들은 남규에게 묻기 시작했다.
결국 앓아누운 남규를 위해 학생들의 질문을 해결할 새로운 프로그램을 만들어보자.

입력
첫 줄에 Y대학교 건물의 수 n과 길의 수 m이 주어진다. (n ≤ 250, m ≤ n * (n - 1) / 2 )
다음 m줄에 걸쳐, u v b (1 ≤ u ≤ n, 1 ≤ v ≤ n, u != v, b = 0 또는 1) 의 형태로 길에 대한 정보가 주어진다.
b가 0일 경우 u에서 v로 가는 일방통행 길인 것이고, b가 1일 경우 u와 v를 잇는 양방향 길이다.
어떤 두 건물 사이를 잇는 길은 최대 한 개이다.
다음 줄에 학생들의 질문의 수 k가 주어진다. (1 ≤ k ≤ 30,000)
다음 k줄에 걸쳐 s e (1 ≤ s ≤ n, 1 ≤ e ≤ n)의 형태로 학생들의 질문들이 주어진다.
이는 질문한 학생이 건물 s에서 건물 e로 가고 싶다는 의미이다.

출력
출력은 k줄에 걸쳐 이루어진다.
각 질문에 대해, 최소 몇 개의 일방통행인 길을 양방향 통행으로 바꿔야 출발지에서 도착지로 갈 수 있는지를 출력한다.
모든 길을 양방향으로 바꾸더라도 서로 도달 불가능한 건물은 없다.
*/





/*
solution:
floyd-warshall 을 사용하는데,
d[i][j]: i->j로 가기위해 양방향으로 바꿔야하는 최소의 단방향 길의 갯수이다.
초기의 양방향 길을 0으로 두고,
단방향 길 u->v는
d[u][v] = 0, d[v][u] = 1이다.


d[i][k] + d[k][j]가 inf가 아니라는 건 길몇개를 바꾸면 i->j로 갈 수 있다는 뜻이다.
*/
#include <iostream>
#include <algorithm>
using namespace std;
const int inf = 0x3f3f3f3f;

int n, m, d[251][251];
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m;
	fill(&d[0][0], &d[0][0] + 251 * 251, inf);
	for (int i = 0; i < m; i++) {
		int u, v, b;
		cin >> u >> v >> b;
		if (b == 1) d[u][v] = d[v][u] = 0;
		else {
			d[u][v] = 0;
			d[v][u] = 1;
		}
	}
	for (int i = 1; i < n + 1; i++) d[i][i] = 0;

	for (int k = 1; k < n + 1; k++) {
		for (int i = 1; i < n + 1; i++) {
			for (int j = 1; j < n + 1; j++) {
				if (d[i][j] > d[i][k] + d[k][j])
					d[i][j] = d[i][k] + d[k][j];
			}
		}
	}
	int k = 0;
	cin >> k;
	while (k--) {
		int u, v;
		cin >> u >> v;
		cout << d[u][v] << '\n';
	}
}
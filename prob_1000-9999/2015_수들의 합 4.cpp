/*
문제
A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다.
이 배열 A의 부분합이란 1<=i<=j<=N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다.
N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N*(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 정수 N과 K가 주어진다. (1<=N<=200,000, |K|<=2,000,000,000) N과 K 사이에는 빈칸이 하나 있다.
둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 주어지는 정수의 절대값은 10,000을 넘지 않는다.

출력
첫째 줄에 합이 K인 부분합의 개수를 출력한다.
*/





/*
solution:
n가지의 정수가 있고, 각 정수를 P(1), P(2), ..., P(n)이라 하자.
각 정수까지의 누적합을 S(1), S(2), ..., S(n)이라 하고 S(0) = 0이라 한다.
범위 [i, j]의 부분합은 S(j)- S(i-1) 으로 구할 수 있다.

문제를 풀기 위해 (1 <= t <= n)인 모든 t와 t보다 작은 정수 u에 대해
[u, t]의 부분합 S(t)-S(u-1) = K 인 [u,t]쌍의 갯수를 구해야한다.

S(t)-S(u-1) = K 
-S(u-1) = K - S(t)
S(u-1) = S(t) - K이므로
t번째 정수 이전의 누적합들 중 누적합이 S(t)-K 인 것들의 갯수를 구하면된다. 
*/
#include <iostream>
#include <map>
using namespace std;

int n, k;
map<int, int> m;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> k;
	int sum = 0;
	long long ans = 0;
	m[0]++;
	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		sum += x;
		ans += m[sum - k];
		m[sum]++;
	}
	cout << ans;
}
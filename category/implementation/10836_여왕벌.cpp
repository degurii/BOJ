/*
문제
크기가 M×M인 격자 형태의 벌집이 있다. 이 벌집의 각 칸에는 여왕벌이 될 애벌레들이 한 마리씩 자라고 있다.
격자칸의 좌표계를 다음과 같이 설정한다. 제일 왼쪽 위 칸의 좌표는 (0,0)이다. 그 아래쪽 칸들의 좌표는 순서대로 (1,0), (2,0), ...등이다.
좌표가 (i,0)인 칸의 오른쪽 칸들의 좌표는 순서대로 (i, 1), (i,2), ... 등이다.

애벌레들은 매일 에너지를 모아서 정오(낮 12시) 에 한번 자라는데, 여기에 걸리는 시간은 매우 짧아서 무시할 수 있다.
첫날 아침 모든 애벌레들의 크기는 1이고, 이러한 과정을 N일 동안 반복한다.

각 애벌레가 자라서 크기가 커지는 정도는 하루에 +0, +1, +2의 세 가지 중 하나이다. 더하기(+) 기호는 앞으로 생략한다.
구체적으로 각 애벌레가 자라는 정도를 결정하는 규칙은 다음과 같다.

제일 왼쪽 열과, 제일 위쪽 행의 애벌레들은 자신이 자라는 정도를 스스로 결정한다.
이들은 입력으로 주어질 것이다.
애벌레들이 자라는 정도를 왼쪽 제일 아래 칸에서 시작하여 위쪽으로 가면서 읽고, 제일 위쪽 칸에 도착하면 오른쪽으로 가면서 행의 끝까지 읽었다고 하자.
모든 입력에서 이렇게 읽은 값들은 감소하지 않는 형태이다.
나머지 애벌레들은 자신의 왼쪽(L), 왼쪽 위(D), 위쪽(U)의 애벌레들이 다 자란 다음, 그 날 가장 많이 자란 애벌레가 자란 만큼 자신도 자란다.

격자칸의 크기, 날자 수, 날자별 제일 왼쪽 열과 제일 위쪽 행의 애벌레들이 자라는 정도를 입력으로 받아
마지막 날 저녁의 애벌레들의 크기를 출력하는 프로그램을 작성하라

입력
입력의 첫 줄에는 격자칸의 가로와 세로 크기 M(2 ≤ M ≤ 700)과 날짜 수 N(1 ≤ N ≤ 1,000,000)이 자연수로 주어진다.
첫날 아침의 애벌레 크기는 모두 1이므로 입력에 주어지지 않는다.
다음 N개의 줄에는 첫날부터 순서대로 제일 왼쪽 열과 제일 위쪽 행의 애벌레들이 자라는 정도가 다음의 형식으로 주어진다.
본문에서 보인 것과 같이, 자라는 크기를 제일 왼쪽 아래 칸에서 시작해서 위쪽으로 올라가서 제일 위쪽에 도착하면 오른쪽으로 이동하며 읽었다고 하자.
이 값들은 감소하지 않는다. 따라서, 이 수열을 처음부터 읽었을 때 0의 개수, 1의 개수, 2의 개수를 순서대로 입력에 준다.
하루에 대해서 이 세 개수들의 합은 2M-1임이 자명하다. 세 값들 중에 0이 있을 수 있다

출력
M개의 줄에 각각 M개의 자연수를 출력한다.
이는 각 애벌레의 마지막 날 저녁의 크기를 첫 행부터, 각 행에서는 왼쪽부터 제시한 것이다. (본문의 예와 동일한 형태이다.)
*/




/*
solution:
n<=1,000,000, m<=700 이므로 시뮬레이션하면 TLE를 받는다.

처음 봐야하는 곳은 맨 왼쪽칸, 맨 윗쪽칸이다.
앞을 (m-1, 0), 뒤를 (0, m-1)이라 하고 
"앞에서부터 뒤로" 라는 말은 (m-1, 0) -> (0, 0) -> (0, m-1) 순서를 뜻한다.

앞에서부터 0, 1, 2가 차례로 채워지므로
한번의 반복이라 가정할 때
1이 처음 나타나는 칸, 2가 처음 나타나는 칸에 체크한다.
이를 n번 반복해야 하므로 체크는 해당 칸에 1씩 더하는 걸로 한다.
(체크할 때 1이 없는 경우라면 2가 시작하는 곳에 +2를 해준다.)

n번 반복이 끝난 뒤
앞에서부터 체크된 칸이 나올 때마다 누적해서 더하고, 
체킹된 칸은 누적합 + (그 칸이 체킹된 횟수),
체크되지 않은 칸은 이때까지의 누적합이 된다.
이렇게 맨 왼쪽열과 맨 윗쪽 행의 값을 구한다.

맨 왼쪽, 맨 윗쪽이 아닌 칸의 값은
항상 같은열의 첫번째 행의 값과 같으므로 출력할 때 구하면 된다.
*/
#include <iostream>
#include <algorithm>
using namespace std;

int m, n;
int p[700][700];
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> m >> n;
	while (n--) {
		int i = m - 1, j = 0;
		int x, y, z;
		cin >> x >> y >> z;
		
		i -= x;
		if (i < 0) {
			j = -i;
			i = 0;
		}
		if (j > m - 1) continue;
		if (y != 0)
			p[i][j]++;
		

		i = m - 1;
		j = 0;
		
		i -= x + y;
		if (i < 0) {
			j = -i;
			i = 0;
		}
		if (j > m - 1) continue;
		p[i][j]++;
		if (y == 0)
			p[i][j]++;
	}
	for (int i = m - 2; i >= 0; i--) {
		p[i][0] += p[i + 1][0];
	}
	for (int j = 1; j < m; j++) {
		p[0][j] += p[0][j - 1];
	}
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < m; j++) {
			if (i == 0 || j == 0)
				cout << p[i][j] + 1 << ' ';
			else
				cout << p[0][j] + 1 << ' ';
		}
		cout << '\n';
	}
}
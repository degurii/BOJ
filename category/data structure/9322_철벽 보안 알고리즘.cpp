/*
문제
소희는 공개키와 개인키 한 쌍으로 보안을 유지하는 것이 매우 불편하다고 생각했다. 그래서 소희는 공개키와 개인키를 암호화 체계를 개발했다. 이를 "철벽 보안 알고리즘"이라고 부르기로 했다. 알고리즘은 다음과 같다.
한 단어는 1~10개의 대문자(A-Z)들로 이루어진 문자열이다. 한 문장은 공백으로 구분된 단어들로 이루어졌다.
제 1 공개키는 최대 한 번만 사용된 단어들로 되어있다.
제 2 공개키는 제 1 공개키의 단어들을 재배치하여 만들어진다.
평문(암호화 되지 않은 문장)은 제 1 공개키와 같이 여러 단어들로 되어있지만, 제 1 공개키와 다르게 각 단어들은 중복이 가능하다.
암호문(암호화 된 문장)은 평문을 제 2 공개키를 만든 규칙의 반대로 재배치하여 만들어진다.
주어진 2개의 공개키와 암호문으로 평문을 복구하라.

입력
입력의 첫 줄에는 테스트 케이스의 수를 의미하는 하나의 정수가 입력된다. 정수는 100을 넘지 않는다.

각 테스트케이스마다 아래 항목들을 한 줄씩 입력받는다.

한 문장의 단어 수 n (1 ≤ n ≤ 1 000)
제 1 공개키
제 2 공개키
암호문
모든 단어들은 최소 1개, 최대 10개의 대문자들로 이루어져있다.

출력
각 케이스마다
암호문을 해독한 평문
을 한 줄에 줄력한다.
*/




/*
solution:
1공개키의 단어 -> 2공개키의 단어 (같은 단어)
의 순서를 역으로 저장한 뒤
평문을 그 순서로 출력한다.
*/
#include <iostream>
#include <string>
#include <map>
using namespace std;

int n;
map<string, int> m;
int rule[1001];
string ans[1001];
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	
	int t;
	cin >> t;
	while (t--) {
		m.clear();
		for (int i = 1; i < n + 1; i++) {
			rule[i] = 0;
			ans[i].clear();
		}
		cin >> n;
		for (int i = 1; i < n + 1; i++) {
			string s;
			cin >> s;
			m[s] = i;
		}
		for (int i = 1; i < n + 1; i++) {
			string s;
			cin >> s;
			rule[i] = m[s];
		}
		for (int i = 1; i < n + 1; i++) {
			string s;
			cin >> s;
			ans[rule[i]] = s;
		}
		for (int i = 1; i < n + 1; i++) {
			cout << ans[i] << ' ';
		}
		cout << '\n';
	}
}